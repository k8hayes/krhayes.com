---
title: "Benchmarking Reburning in iLand"
subtitle: "Using terra to quantify overlaps in fire perimeter rasters"
date: "2024-04-15"
categories: [Spatial Data Analysis, Benchmarking]
date-modified: last-modified
format:
  html:
    toc: true
    toc-location: left
    grid:
      margin-width: 350px
reference-location: margin
citation-location: margin
draft: true
---

# Fire output in iLand

## Determining which fires in iLand were stand-replacing

First, I need to determine which fires in my iLand run were "stand-replacing" - The fire output in iLand produces a table of each fire, shown below.

```{r loading in fire}
#| eval: false
#| echo: false
#| tbl-cap-location: margin
 # loading in fire output
  fire <- read.csv("D:/workspace/Kate/iland/model/output/output_csv/snapshot/fire.csv")

 knitr::kable(head(fire))
```

There's two ways to represent fire severity using this output: the **proportion of trees killed** within each fire, and the **proportion of basal area killed**. Those two metrics are distinct in slight yet important ways - a fire might kill all trees in a young stand but if the trees themselves were small, the impact on basal area won't be terribly large. Or, a fire might kill only the largest/oldest individuals in a stand, thus impacting carbon greatly in a way that wouldn't show up using just **proportion of trees killed**. Here, since we're interested in how forests are regenerating, we'll focus on instances where fires killed all trees, but I'll show both for the sake of it.

```{r proportion killed}
#| eval: false
# drop the fire years where there was no burn
  fire <- fire[fire$area_m2 > 0,] # no fire years with no burn
  length(unique(fire$fireId)) # how many fires occurred across the simulation?

  fire <- fire %>% 
    mutate( # how many trees were killed?
              prop.dens.killed = n_trees_died / n_trees, 
            # what basal area was killed?
              prop.ba.killed = basalArea_died / basalArea_total) 
      
      fire$prop.ba.killed[fire$basalArea_total == 0] <- 0 # set to 0
      fire$prop.dens.killed[fire$n_trees == 0] <- 0
```

However, there's one challenge with this:

```{r hist of prop dens killed}
#| eval: false
#| label: fig-stems-killed
#| fig-cap: "Percent of stems killed across fires"
#| cap-location: margin
#| warning: false
hist(fire$prop.dens.killed * 100,
     breaks = seq(0, 100, 5),
     main = paste0("Stems killed in fires. Mean: ", 
              round((mean(fire$prop.dens.killed)*100.0), 1), "%"),
     xlab = "Percent of stems killed")
```

```{r hist of basal killed}
#| eval: false
#| label: fig-ba-killed
#| fig-cap: "Percent basal area killed across fires"
#| cap-location: margin
#| warning: false
hist(fire$prop.ba.killed * 100,
     breaks = seq(0, 100, 5),
     main = paste0("Basal area killed in fires. Mean: ",
                   round((mean(fire$prop.ba.killed)*100.0), 1), "%"),
     xlab = "Percent of basal area killed")
```

You'll notice neither metric shows values that are completely equal to 100%. At first this seems like a problem, right?[^1]

[^1]: none of our fires were stand-replacing??

This is an important nuance of the iLand fire output - **n_trees_killed** and **basalArea_died** are aggregated across the entire fire. Cells within the fire may have experienced full canopy mortality, but since we're working with averages, it'll be very very rare (if not impossible) for a stand to have 100% of stems killed across the entire fire.

## Saving additional fire output

We'll need more detail, and thankfully there's a fun way to solve this - by adding a javascript file to the **scripts** folder, you can add code that tells iLand to save raster files of the perimeter of each fire with additional information. Some options of things to turn on include:

-   **crownKill**: fraction of the crown killed within a burned resource unit (see [wildfire](https://iland-model.org/wildfire "fire disturbance modeling") ).
-   **diedStemsFrac**: fraction of killed trees within a burned resource unit
-   **diedBasalArea**: basal area (sum over resource units) of burnt trees.
-   **KBDI**: Keetch Byram Drought Index (see [wildfire](https://iland-model.org/wildfire "fire disturbance modeling") ).
-   **baseIgnition**: base probability of an annual fire ignition event for a cell on RU level (depending on fire-return-interval and average fire size)
-   **fuel**: burned fuel (forest floor + dwd) kg/ha
-   **combustibleFuel**: "available combustible fuel (current KBDI, forest floor + dwd) kg/ha
-   **nFire**: cumulative count of fire events on a resource unit[^2]
-   **lastFireYear**: simulation year of the last fire event on a RU

[^2]: Breaking the forth wall: discovered this output while putting together this quarto document. In future runs, I'll turn this on and avoid some of the steps described later in the document to filter out reburns

For this analysis, we'll stick to **diedStemsFrac** - the number of stems killed within a resource unit. First, you need to add a function into your iLand model to tell it to save the extra output.

The code to do so is the following:

```{js saving fire output }
#| eval: false
function afterFireProcessing() {
   var praefix = Globals.year;
   var pid= Fire.id;
   // save the form of the fire in ESRI raster format
   // save a file for each fire
   Fire.grid("diedStemsFrac").save('output/dead/dead_'+ pid +'.txt')
}
```

Add this in to a javascript file within the **Scripts** folder in your iLand folder ecosystem, and enable \<management\> under \</model\> in your project file. Now, if you set up a **"dead"** folder in your output, a raster of values of stems killed will save after each fire.[^3]

[^3]: To track other items from the list of variables above, call a new Fire.grid() within the afterFireProcessing function and give it a unique save destination

In order to filter our sapling output by the cells that experienced canopy-replacing fire, we can filter not only by the rasters (the footprint of the fire), but by the value of **diedStemsFraction** variable within each raster pixel (which represent resource units in the iLand landscape).

::: callout-note
Question: does **diedStemsFraction** include saplings and trees or just trees?
:::

Then, load the fire perimeters into R:

```{r loading in rasters}
#| eval: false
# stacking fire spread files
      path = "D:/workspace/Kate/iland/model/output/dead/snapshot"
      fire_maps = rast(list.files(path, full.names = T))
    
# also bring in the environment grid 
  # we'll use this to get ids for each grid
      env.grid = rast("D:/workspace/Kate/iland/materials/env/env.grid.tif")
```

The function **rast()** from the *terra* package [@terra] creates a **SpatRaster** object, a object type in R that can represent multi-layer or multi-variable raster data. Here, the object **fire_maps** we just created is a three-dimensional raster - the first two dimensions are the x and y axis of our iLand landscape and the third dimension is 27 layers of fire perimeters (one for each fire within the simulation). Each pixel within that raster represents an individual resource unit from the iLand landscape and contains a value from 0 -1, representing **diedStemsFrac.**

```{r printing fire_maps}
#| eval: false
fire_maps 

nlyr(fire_maps) # 27 layers, one for each fire

head(values(fire_maps))
```

We can call on each of those 27 layers to examine the fire perimeters one by one. For example, this is the fire perimeter from the first fire in the simulation:

```{r plotting fire_maps}
#| eval: false
#| label: fig-fireEx1
#| fig-cap: "Fire Perimeter of first fire in spin-up simulation. The color gradient represents diedStemsFrac as a value from 0 to 1."
#| cap-location: margin
#| echo: false
plot(fire_maps[["dead_1"]])
```

We'll use these rasters to determine which resource units experienced stand-replacing fire[^4], and use those resource unit IDs to filter the sapling and tree data.

[^4]: Which we can now define more specifically as **diedStemFrac** = 1

::: callout-note
An aside: this run is a spin-up simulation - I ran iLand, initializing forests from an empty landscape[^5] in year 0, and simulated forest growth and fire over 300 years. This seems to be the sweet spot for simulation runs - at year 300, we have a landscape full of a mix of mature, regenerating and recently burned stands, just as we'd observe in real life. Since fires that occur early in the spin-up inherently burn young stands, it's not terribly representative of the relationship between height and age in regrowth that we want to eventually compare to the herbivore-impacted relationship. So, we'll filter to just the last 100 years of the simulation.
:::

[^5]: An aside to the aside (meta!!) - it's an empty landscape in the sense that there are no trees in year 0, but we do initialize using a soil organic layer that varies heterogeneously according to XX across the landscape. This isn't just to represent real life for real life's sake - initializing from truly empty (truly bare ground) causes totally different patterns of forests. As has been shown in decades of work in Alaska by Jill Johnstone and others, soil organic layer filters forest community composition in really critical ways, allowing spruce to outcompete species like birch and aspen which can't persist in thick soil or moss layers for as long.

```{r filter to last 100}
#| eval: false
  # filtering to last 100 years of fire
  fire100 <- fire %>%
    filter(year >200)
  length(unique(fire100$fireId)) # How many fires in the last 100 years?
  unique(fire100$fireID)
  
  # dropping layers from fire raster
  fire_maps100 <- subset(fire_maps, paste0("dead_", fire100$fireId))
```

### A quick (haha) aside: Reburns

::: column-margin
you can take the girl out of the Reburn PhD, but you can't take the Reburn PhD out of the girl
:::

Even within the relatively narrow window of 100 years[^6], reburning occurs within the model! Here's the footprint of all fires in the last 100 years of the spin up - you can see there's some considerable overlap, or reburning.

[^6]: Particularly since the historic fire return interval for this system was somewhere between 100-300 years [@kelly2013]

```{r plotting all fire_maps}
#| eval: false
#| label: fig-fire_overlap
#| fig-cap: "All fire perimeters from the last 100 years of the spin-up simulation."
#| cap-location: margin
  # setting background to NA to make transparent
  fire_mapsNA <- subst(fire_maps100, 0, NA) # need to do this anyways but now it'll let us stack
  
  plot(fire_mapsNA["dead_18"])
  plot(fire_mapsNA["dead_19"], add = TRUE, legend = FALSE)
  plot(fire_mapsNA["dead_20"], add = TRUE, legend = FALSE)
  plot(fire_mapsNA["dead_21"], add = TRUE, legend = FALSE)
  plot(fire_mapsNA["dead_22"], add = TRUE, legend = FALSE)
  plot(fire_mapsNA["dead_23"], add = TRUE, legend = FALSE)
  plot(fire_mapsNA["dead_24"], add = TRUE, legend = FALSE)
  plot(fire_mapsNA["dead_25"], add = TRUE, legend = FALSE)
  plot(fire_mapsNA["dead_26"], add = TRUE, legend = FALSE)
  plot(fire_mapsNA["dead_27"], add = TRUE, legend = FALSE)
```

#### Determining overlap between rasters using the *terra* package

I'm curious both about the overlap between fire perimeters and the interaction of fire severity

##### Fire perimeter reburning

The **intersect()** function in *terra* is useful for checking overlap, but only takes two rasters at a time:

```{r intersect terra}
#| eval: false
#| label: fig-cap-margin
#| fig-cap: "Overlap between first two fires"
#| cap-location: margin
overlap <- terra::intersect(fire_mapsNA[["dead_18"]],
                            fire_mapsNA[["dead_19"]])

plot(overlap)
```

Ideally, we'd be able to check the intersect of all of the fires at once - I'm sure there's a way to do this in a loop, but I'm not strong enough with loops to get it to work. I've tried the following:

```{r attempt at intersect loop}
#| eval: false
overlap <- rast()

for (i in 1:length(fire100$fireId)) {
  
    fire1 <- fire_mapsNA[[paste0("dead_", fire100$fireId[i])]]
    fire2 <- fire_mapsNA[[paste0("dead_", 
                                 ifelse(i != max(fire100$fireId), i+1,
                                        max(fire100$fireId)))]]
    
    temp <- intersect(fire1,fire2)
    names(temp) <- paste0("intersect_", i)
    overlap <- rast(temp)
}
```

Which doesn't work.

There's also the **mosaic()** function in *terra*:

```{r mosaic}
#| eval: false
#| label: fig-mosaic
#| fig-cap: "Testing collapsing layers"
#| cap-location: margin
#| warning: false
# split all the layers into a list
mapList <- terra::split(fire_mapsNA, 1:nlyr(fire_mapsNA))

# turn list into SpatRaster Collection
mapSPC <- terra::sprc(mapList) 

# merge values across layers
reburn <- terra::mosaic(mapSPC, fun = "sum")
plot(reburn)
```

Yay!! Okay!! Now, if we set all the values of the layers to 1, we'll end up with a raster of number of fires.

```{r setting values to 1}
#| eval: false
#| warning: false
perim <- fire_maps100 > 0

# setting values to 1 and na
perim <- subst(perim, TRUE, 1, others = NA)

```

```{r overlapping fire perim}
#| eval: false
#| label: fig-reburnhist
#| fig-cap: "Reburn history"
#| cap-location: margin
#| warning: false
# split all the layers into a list
perimList <- terra::split(perim, 1:nlyr(perim))

# turn list into SpatRaster Collection
perimSPC <- terra::sprc(perimList) 

# merge values across layers
nFire <- terra::mosaic(perimSPC, fun = "sum")
plot(nFire)
```

yay!! Now we can filter by the value of **nFire** to get the specific resource units that burned and eventually exclude them for the analysis.

A few more exploratory tangential questions since we're here:

How much of the landscape burned once?

```{r once burned}
#| eval: false
#| label: fig-1xperim
#| fig-cap: "1x fire perimeters"
#| cap-location: margin
#| warning: false
nfire1 <- subst(nFire, 1, 1, others = NA)
plot(nfire1)

# what RID burned once?
nfire1rid <- as.data.frame(mask(env.grid, nfire1))

# how many unique resource units are there?
domain <- ncell(env.grid) # dimensions are 239 by 255 

# how many resource units burned once?
length(unique(nfire1rid$env.grid)) 

# so, what %?
round((length(unique(nfire1rid$env.grid)) / domain) *100, 1)
```

How much burned twice?

```{r twice burned}
#| eval: false
#| label: fig-2xperim
#| fig-cap: "2x fire perimeters"
#| cap-location: margin
#| warning: false
nfire2 <- subst(nFire, 2, 1, others = NA)
plot(nfire2)

# what RID burned twice?
nfire2rid <- as.data.frame(mask(env.grid, nfire2))

# so, what %?
round((length(unique(nfire2rid$env.grid)) / domain) *100, 1)

```

How much burned three times?

```{r thrice burned}
#| eval: false
#| label: fig-3xperim
#| fig-cap: "3x fire perimeters"
#| cap-location: margin
#| warning: false
nfire3 <- subst(nFire, 3, 1, others = NA)
plot(nfire3)

# what RID burned thrice?
nfire3rid <- as.data.frame(mask(env.grid, nfire3))

# so, what %?
round((length(unique(nfire3rid$env.grid)) / domain) *100, 1)
```

Now, we can introduce one more layer: these are all cells that burned, not the cells that burned at high severity. In theory, we[^7] often expect reburns (or fires that burn into existing fire perimeters) to occur at diminishing severity. Depending on the window between fires, fuel availability may limit combustion in reburns. Based on that logic, are there overlaps between stands that burned at high severity?

[^7]: we, the royal fire ecologists

```{r plotting just high severity}
#| eval: false
#| label: fig-HS
#| fig-cap: "High severity fires"
#| cap-location: margin
#| warning: false
# filter to just stands with high severity
  # cells with diedStemsFrac = 1
  fire_mapsHS <- subst(fire_maps, 1, 1, others = NA)
  
  plot(fire_mapsHS[["dead_18"]])
  plot(fire_mapsHS[["dead_19"]], add = TRUE, legend = FALSE)
  plot(fire_mapsHS[["dead_20"]], add = TRUE, legend = FALSE)
  plot(fire_mapsHS[["dead_21"]], add = TRUE, legend = FALSE)
  plot(fire_mapsHS[["dead_22"]], add = TRUE, legend = FALSE)
  plot(fire_mapsHS[["dead_23"]], add = TRUE, legend = FALSE)
  plot(fire_mapsHS[["dead_24"]], add = TRUE, legend = FALSE)
  plot(fire_mapsHS[["dead_25"]], add = TRUE, legend = FALSE)
  plot(fire_mapsHS[["dead_26"]], add = TRUE, legend = FALSE)
  plot(fire_mapsHS[["dead_27"]], add = TRUE, legend = FALSE)

```

Obviously less area there. Is there any overlap?

```{r hs reburns}
#| eval: false
# split all the layers into a list
hsList <- terra::split(fire_mapsHS, 1:nlyr(fire_mapsHS))

# turn list into SpatRaster Collection
hsSPC <- terra::sprc(hsList) 

# merge values across layers
nFireHS <- terra::mosaic(hsSPC, fun = "sum")
plot(nFireHS)

```

Okay. Pretty sparse, but technically there's still resource units that burned completely both times.

```{r reburned HS}
#| eval: false
nfireHS2 <- subst(nFireHS, 2, 1, others = NA)
plot(nfireHS2)

# what RID burned twice at HS?
nfireHS2rid <- as.data.frame(mask(env.grid, nfireHS2))

# so, what %?
(length(unique(nfireHS2rid$env.grid)) / domain) *100
```

I'm curious about the years that burned twice at high severity. What's the interval between them?

```{r interval between HS reburn}
#| eval: false

```

## Filtering sapling by high severity fire

Now, we want to use the row id numbers from the **fire_mapsHS** object to filter out rows in the **sapling** and **stand** output that burned at high severity. The following code loops through each of the fire maps, extracting the resource unit ID numbers, the fire ID and the fire year (which come from the default fire output) and compiling into a dataframe, **fireID**.

```{r extracting fire info snapshot}
#| eval: false
#| warning: false
fireID <- data.frame()

for (i in 1:nrow(fire100)) {
  
  # Skip fires that burned nothing
  if (fire100$area_m2[i] > 0) {
  
    mask <- fire_mapsHS[[paste0("dead_", fire100$fireId[i])]]
    
    # Use the mask to extract the rids for burned grids
    burned_rids <- as.data.frame(mask(env.grid, mask))
    burned_rids= burned_rids%>%filter(!is.na(env.grid))
    burned_rids$year=fire100$year[i]
    burned_rids$fireID = fire100$fireId[i]
  }
  
  fireID = rbind(fireID, burned_rids)
}

fireID = fireID %>% rename("rid" = env.grid, "fire.year" = year)

```

What fraction of the landscape burned at high severity? (ie, how many resource units?)

```{r what fraction HS}
#| eval: false
# how many unique resource units are there?
domain <- ncell(env.grid) # dimensions are 239 by 255 

# how many resource units burned at HS?
length(unique(fireID$rid)) 

# so, what %?
(length(unique(fireID$rid)) / domain) *100
```

So, only about 1% of the landscape burned at high severity across the 100 year simulation window. (Though, technically that would be an underestimate since it doesn't take into account the resource units that reburned). Let's go ahead and exclude the resource units that reburned:

```{r excluding reburns from HS}
#| eval: false
  fireID <- fireID %>%
      filter(rid %in% nfireHS2rid$env.grid)
```

## Session info

```{r session info}
sessionInfo()
```
