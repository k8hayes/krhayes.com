{
  "hash": "3d8ca7e961fbef8ce6e92547a6a01abc",
  "result": {
    "markdown": "---\ntitle: Calculating light availability from fisheye photos\nsubtitle: How to use the package hemispheR\ndescription: Ft. pretty pictures\ndate: 2024-08-19\ncategories: [Spatial Data Analysis, Workflow]\ndate-modified: last-modified\nbibliography: references.bib\n---\n\n\nAs part of my PhD trying to capture the impact of reburning on boreal forests, I measured understory plant communities in my study sites. I don't have a background in community ecology, but have been working with a labmate and friend to understand the impact of reburning on the communities we measured. As part of that effort, I've been curious about light availability - the reburned stands I worked in as a PhD became more and more open with more reburning, and presumably that means more light would reach the understory.\n\nIn order to capture the light coming through the canopy in these sites, there was a moment in our sampling protocol where we set up a camera with a fisheye lens on a flat surface in the middle of the plot, laid down on our backs trying to hid in the vegetation around us, and looked up at the sky.[^1]\n\n[^1]: My favorite part of sampling, for the record.\n\n![We weren't always able to sneak out of the frame successfully, peep my trusty field hat at the top](images/outtake.JPG)\n\nTo convert pictures like these into measurements of the light coming through the canopy, I've been exploring how to use the *hemispheR* package in R.\n\n# Introduction to hemispheR\n\n*hemispheR* was built to help process digital hemispherical photography (DHP) [@hemispheR]. It calculates leaf area index, a ratio of total leaf area of vegetation to the surface area grown, using equations predicting the relationship between the surface area of leaves and the fraction of light they intercept.\n\nWhile leaf area index is really useful, I'm mostly interested in light availability more broadly - I'm really just looking for the fraction of canopy to open sky. *hemispheR* classifies pixels within an image as either canopy or sky as a step to calculating leaf area index, so it should work great for this.\n\n\n::: {.cell}\n\n:::\n\n\nI'll start by importing one of our canopy photos. Here's the image:\n\n![This is a picture from one of our mature plots - note the black spruce all around the edges of the photo.](images/11_0.JPG)\n\n*import_fisheye()* imports the photo as a raster, defining the edges of the picture.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nph11_0 <- import_fisheye(filename = \"/Users/katherinehayes/Library/CloudStorage/GoogleDrive-k8rhayes@gmail.com/My Drive/Work/Website/krhayes.com/posts/Post_hemispheR/images/11_0.JPG\",\n                       circular = TRUE, display = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nIt is a circular fisheye, where xc, yc and radius are 2456, 1632, 1630\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/importing 11_0-1.png){width=672}\n:::\n:::\n\n\nUsing *binarize_fisheye()*, I can classify the pixels as either canopy (0) or sky (1).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nph11_0bin <- binarize_fisheye(ph11_0)\n\nplot(ph11_0bin)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/11_0 binarize-1.png){width=672}\n:::\n:::\n\n\nThen, I'll convert the raster into a data.frame so I can calculate the percent of open sky:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nph11_0data <- as.data.frame(ph11_0bin) # 0 is canopy # 1 is sky\n```\n:::\n\n\nWhat percent is sky?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(length(which(ph11_0data == 1)) / nrow(ph11_0data) * 100, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 19.58\n```\n\n\n:::\n:::\n\n\nNow, I'll compare that to a picture from one of our thrice-burned plots. Again, here's the original image:\n\n![obviously more open right off the bat](images/23_3.JPG)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nph23_3 <- import_fisheye(filename = \"/Users/katherinehayes/Library/CloudStorage/GoogleDrive-k8rhayes@gmail.com/My Drive/Work/Website/krhayes.com/posts/Post_hemispheR/images/23_3.JPG\",\n                       circular = TRUE, display = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nIt is a circular fisheye, where xc, yc and radius are 2456, 1632, 1630\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/23_3 import-1.png){width=672}\n:::\n:::\n\n\nThe obvious visual differences continue when you convert to a binary:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nph23_3bin <- binarize_fisheye(ph23_3, display = TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/23_3 binary-1.png){width=672}\n:::\n:::\n\n\nThere's one issue here - it seems like the binary classified the bottom half of the sky incorrectly. How can we fix that?\n\nOne option is zones - setting zonal = **TRUE** in *binarize_fisheye()* tells the function to split the image into four zones, calculating each separately. Let's try it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nph23_3bin <- binarize_fisheye(ph23_3, zonal = TRUE, display = TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/23_3 binarize zones-1.png){width=672}\n:::\n:::\n\n\nThat's a lot better, but still not perfect. Note how there's now 4 different threshold values. Threshold values are set automatically, but you can also set them manually.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# using the smallest value from the zones above\nph23_3bin <- binarize_fisheye(ph23_3, manual = 37, display = TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/23_3 manual-1.png){width=672}\n:::\n:::\n\n\nNow that matches the raw picture. and the percent sky?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nph23_3data <- as.data.frame(ph23_3bin) # 0 is canopy # 1 is sky\n\nround(length(which(ph23_3data == 1)) / nrow(ph23_3data) * 100, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 83.3\n```\n\n\n:::\n:::\n\n\n# Automating hemispheR\n\nNow, I'd like to replicate this 50 times, reading in each picture and extracting the ratio of canopy to sky. Here's the code to do so:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define the path to your folder containing JPG files\nfolder_path <- \"data/canopy pictures/\"\n\n# List all JPG files in the folder\nfile_list <- list.files(path = folder_path, pattern = \"\\\\.JPG$\", full.names = TRUE)\n\n# Initialize an empty data frame to store results\nresults <- data.frame(\n  plot = character(),\n  ratio = integer(),\n  percentSky = integer(),\n  stringsAsFactors = FALSE\n)\n\nfor (file_path in file_list) {\n  \n  photo <- hemispheR::import_fisheye(filename = file_path,\n                       circular = TRUE, message = FALSE)\n  \n  photo_bin <- binarize_fisheye(photo, zonal = TRUE)\n  \n  photoData <- as.data.frame(photo_bin)\n  \n  ratio <- length(which(photoData == 1)) / length(which(photoData == 0))\n  \n  percentSky <- length(which(photoData == 1)) / nrow(photoData)\n  \n  # Append the results to the data frame\n  results <- rbind(results, data.frame(\n    plot = file_path,\n    ratio = ratio,\n    percentSky = percentSky,\n    stringsAsFactors = FALSE\n  ))\n  \n}\n\nresults <- results %>%\n  mutate(plot = sub(\".JPG\", \"\", sub(\".*//\", \"\", results$plot)),\n         treat = as.numeric(sub(\".*_\", \"\", plot)))\n\nresults <- left_join(results, index, by = join_by(plot, treat))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nkable(head(results))\n```\n\n::: {.cell-output-display}\n\n\n|plot |     ratio| percentSky| treat|site   |\n|:----|---------:|----------:|-----:|:------|\n|10_0 | 0.1785791|  0.1515206|     0|DALTON |\n|11_0 | 0.2489218|  0.1993094|     0|DALTON |\n|12_1 | 1.3648933|  0.5771479|     1|DALTON |\n|15_3 | 0.8467842|  0.4585182|     3|DALTON |\n|16_2 | 0.7529837|  0.4295440|     2|DALTON |\n|17_3 | 1.7729908|  0.6393785|     3|STEESE |\n\n\n:::\n:::\n\n\n# How does exposed sky differ across reburn?\n\nSo, what does that actually look like?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(results, aes(x = as.factor(treat), \n                    y = percentSky*100, fill = site)) +\n  geom_boxplot() +\n  labs(x = \"Number of Fires\", y = \"Percent Sky %\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nSo, much more sky exposed in burned and reburned plots compared to our mature ones (with the caveat that we didn't take pictures in the mature steese sites). On average, more sky is exposed in the Steese sites, but the trends are roughly the same.\n\n# What's the relationship between exposed sky and tree density?\n\nPresumably the mechanism for that is tree density, but now we can check the relationship between the two. I'll load and process our density data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndensity <- read.csv(\"/Users/katherinehayes/Library/CloudStorage/GoogleDrive-k8rhayes@gmail.com/My Drive/Work/Website/krhayes.com/posts/Post_hemispheR/data/density.csv\")\n\ndensity_count <- density %>%\n  group_by(SITE, TREAT, PLOT) %>%\n  summarise(count_ha = sum(TREE_COUNT_HA)) %>%\n  rename(plot = PLOT, site = SITE, treat = TREAT)\n\nresults <- left_join(results, density_count, by = join_by(site, plot, treat))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(results, aes(x = count_ha / 10000, y = percentSky*100)) + \n  geom_point(aes(shape = as.factor(treat), col = as.factor(treat)), size = 2) + \n  geom_smooth(aes(col = as.factor(treat), \n                  fill = as.factor(treat)), \n              method = \"lm\" , alpha = 0.1) +\n  labs(x = \"Density (Tree per m2)\", y = \"% sky\") +\n  scale_color_manual(name = \"Number of fires\", \n                     values = c(\"#d73027\", \"#d9ef8b\",\"#91cf60\",\"#1a9850\")) +\n  scale_shape_manual(name = \"Number of fires\",\n                     values = c(15, 17, 19, 3)) +\n  scale_fill_manual(name = \"Number of fires\",\n                     values = c(\"#d73027\", \"#d9ef8b\",\"#91cf60\",\"#1a9850\")) \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/density plot-1.png){width=672}\n:::\n:::\n\n\nSo, overall, more exposed sky at lower tree densities. Some exceptions, in the 3x burns\n\n# What's the relationship between canopy openness and solar irradiance?\n\nI've also used solar irradiance[^2] before as a proxy for light availability. How similar are those metrics?\n\n[^2]: essentially the strength of the sun in a given location, measured in watts per square meter. For our analysis, we've calculated it in arcGIS using the solar radiation toolset which takes x and y coordinates, slope and aspect and averages incoming solar radiation across a year\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsolar <- read.csv(\"/Users/katherinehayes/Library/CloudStorage/GoogleDrive-k8rhayes@gmail.com/My Drive/Work/Website/krhayes.com/posts/Post_hemispheR/data/site_attrib.csv\")\n\nsolar <- solar %>%\n  rename(plot = PLOT, site = SITE, treat = TREAT, solar = SOLAR) %>%\n  select(c(site, plot, treat, solar))\n\nresults <- left_join(results, solar, by = join_by(site, plot, treat))\n\nggplot(results, aes(x = solar, y = percentSky*100)) + \n  geom_point(aes(shape = as.factor(treat), col = as.factor(treat)), size = 2) + \n  geom_smooth(aes(col = as.factor(treat), \n                  fill = as.factor(treat)), \n              method = \"lm\" , alpha = 0.1) +\n  labs(x = \"Solar irradiance\", y = \"% sky\") +\n  scale_color_manual(name = \"Number of fires\", \n                     values = c(\"#d73027\", \"#d9ef8b\",\"#91cf60\",\"#1a9850\")) +\n  scale_shape_manual(name = \"Number of fires\",\n                     values = c(15, 17, 19, 3)) +\n  scale_fill_manual(name = \"Number of fires\", \n                     values = c(\"#d73027\", \"#d9ef8b\",\"#91cf60\",\"#1a9850\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/solar irradiance-1.png){width=672}\n:::\n\n```{.r .cell-code}\ncor(results$percentSky, results$solar)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.2904864\n```\n\n\n:::\n\n```{.r .cell-code}\ncor(results$solar, results$ratio)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1626447\n```\n\n\n:::\n:::\n\n\nThis, and the correlation coefficients seem to show that solar irradiance and the percent of sky visible from the photos aren't really equivalent - said another way, they aren't interchangeable as proxies of light availability. We've been using just solar irradiance in our analysis, and it doesn't seem to have an impact on understory species communities - given the difference between the two, perhaps exposed sky will. Stay tuned!\n\n![a very pretty, very open reburned plot](images/reburned%20stand.JPG)\n\n# More Resources\n\n## Session Info\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.4.1 (2024-06-14)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Sonoma 14.0\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: America/Chicago\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] cowplot_1.1.3    lubridate_1.9.3  forcats_1.0.0    stringr_1.5.1   \n [5] dplyr_1.1.4      purrr_1.0.2      readr_2.1.5      tidyr_1.3.1     \n [9] tibble_3.2.1     ggplot2_3.5.1    tidyverse_2.0.0  kableExtra_1.4.0\n[13] hemispheR_1.1.4  terra_1.7-78    \n\nloaded via a namespace (and not attached):\n [1] gtable_0.3.5         xfun_0.45            raster_3.6-26       \n [4] htmlwidgets_1.6.4    lattice_0.22-6       tzdb_0.4.0          \n [7] vctrs_0.6.5          tools_4.4.1          generics_0.1.3      \n[10] proxy_0.4-27         fansi_1.0.6          pkgconfig_2.0.3     \n[13] Matrix_1.7-0         KernSmooth_2.23-24   checkmate_2.3.2     \n[16] lifecycle_1.0.4      farver_2.1.2         compiler_4.4.1      \n[19] munsell_0.5.1        ijtiff_2.3.4         dismo_1.3-14        \n[22] codetools_0.2-20     htmltools_0.5.8.1    class_7.3-22        \n[25] yaml_2.3.8           pillar_1.9.0         classInt_0.4-10     \n[28] nlme_3.1-165         tidyselect_1.2.1     digest_0.6.36       \n[31] stringi_1.8.4        sf_1.0-16            splines_4.4.1       \n[34] labeling_0.4.3       fastmap_1.2.0        grid_4.4.1          \n[37] colorspace_2.1-0     cli_3.6.3            magrittr_2.0.3      \n[40] utf8_1.2.4           e1071_1.7-14         withr_3.0.0         \n[43] autothresholdr_1.4.2 backports_1.5.0      scales_1.3.0        \n[46] sp_2.1-4             timechange_0.3.0     rmarkdown_2.27      \n[49] hms_1.1.3            evaluate_0.24.0      knitr_1.47          \n[52] viridisLite_0.4.2    mgcv_1.9-1           rlang_1.1.4         \n[55] Rcpp_1.0.12          zeallot_0.1.0        glue_1.7.0          \n[58] DBI_1.2.3            xml2_1.3.6           strex_2.0.0         \n[61] svglite_2.1.3        rstudioapi_0.16.0    jsonlite_1.8.8      \n[64] R6_2.5.1             systemfonts_1.1.0    units_0.8-5         \n```\n\n\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}