{
  "hash": "912c309aa25fc343b17283513f001c66",
  "result": {
    "markdown": "---\ntitle: Calculating light availability from fisheye photos\nsubtitle: How to use the package hemispheR\ndate: 2024-08-19\ncategories: [Spatial Data Analysis, Workflow]\ndate-modified: last-modified\nbibliography: references.bib\n---\n\n\nAs part of my PhD trying to capture the impact of reburning on boreal forests, I measured understory plant communities in my study sites. I don't have a background in community ecology, but have been working with a labmate and friend to understand the impact of reburning on the communities we measured. As part of that effort, I've been curious about light availability - the reburned stands I worked in as a PhD became more and more open with more reburning, and presumably that increase in the availability of light would help certain members of the understory.\n\n\\[insert photos from stands here\\]\n\nIn order to capture the light coming through the canopy in these sites, there was a moment in our sampling protocol where we set up a camera with a fisheye lens on a flat surface in the middle of the plot, laid down on our backs trying to hid in the vegetation around us[^1], and looked up at the sky. My favorite part of sampling, for the record.\n\n[^1]: We weren't always able to sneak out of the frame successfully...\n\n![](images/outtake.JPG){.column-margin}\n\nTo convert pictures like these into measurements of the light coming through the canopy, I've been exploring how to use the [@hemispheR] package in R.\n\n# Introduction to hemispheR\n\n[@hemispheR] was built to help process digital hemispherical photography (DHP). It calculates leaf area index, a ratio of total leaf area of vegetation to the surface area grown, using equations predicting the relationship between the surface area of leaves and the fraction of light they intercept.\n\nWhile leaf area index is really useful, I'm mostly interested in light availability more broadly - I'm really just looking for the fraction of canopy to open sky. [@hemispheR] classifies pixels within an image as either canopy or sky as a step to calculating leaf area index, so it should work great for this.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: terra\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nterra 1.7.78\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ tidyr::extract()    masks terra::extract()\n✖ dplyr::filter()     masks stats::filter()\n✖ dplyr::group_rows() masks kableExtra::group_rows()\n✖ dplyr::lag()        masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n\nAttaching package: 'cowplot'\n\n\nThe following object is masked from 'package:lubridate':\n\n    stamp\n```\n\n\n:::\n:::\n\n\nI'll start by importing one of our canopy photos.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nph11_0 <- import_fisheye(filename = \"images/11_0.JPG\",\n                       circular = TRUE, display = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nIt is a circular fisheye, where xc, yc and radius are 2456, 1632, 1630\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/importing 11_0-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(ph11_0)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/importing 11_0-2.png){width=672}\n:::\n:::\n\n\nThis is a picture from one of our mature plots - note the black spruce all around the edges of the photo.\n\nUsing the binarize_fisheye() function, I can classify the pixels as either canopy (0) or sky (1).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nph11_0_bin <- binarize_fisheye(ph11_0, display = TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/11_0 binarize-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(ph11_0_bin)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/11_0 binarize-2.png){width=672}\n:::\n:::\n\n\nThen, I'll convert the raster into a data.frame so I can calculate the ratio of canopy to sky:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nph11_0_data <- as.data.frame(ph11_0_bin) # 0 is canopy # 1 is sky\n\n# ratio of canopy to sky\nlength(which(ph11_0_data == 0)) / length(which(ph11_0_data == 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.106016\n```\n\n\n:::\n:::\n\n\nOr, said another way, the fraction of sky:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(which(ph11_0_data == 0)) / nrow(ph11_0_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.8041526\n```\n\n\n:::\n:::\n\n\nNow, I'll compare that to a picture from one of our thrice-burned plots:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nph23_3 <- import_fisheye(filename = \"images/23_3.JPG\",\n                       circular = TRUE, display = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nIt is a circular fisheye, where xc, yc and radius are 2456, 1632, 1630\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/23_3 binarize-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(ph23_3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/23_3 binarize-2.png){width=672}\n:::\n:::\n\n\nDifferent ratios:\n\n\n::: {.cell}\n\n:::\n\n\n# Automating hemispheR\n\nNow, I'd like to replicate this 50 times, reading in each picture and extracting the ratio of canopy to sky. Here's the code to do so:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define the path to your folder containing JPG files\nfolder_path <- \"data/canopy pictures/\"\n\n# List all JPG files in the folder\nfile_list <- list.files(path = folder_path, pattern = \"\\\\.JPG$\", full.names = TRUE)\n\n# Initialize an empty data frame to store results\nresults <- data.frame(\n  plot = character(),\n  ratio = integer(),\n  percentSky = integer(),\n  stringsAsFactors = FALSE\n)\n\nfor (file_path in file_list) {\n  \n  photo <- hemispheR::import_fisheye(filename = file_path,\n                       circular = TRUE, message = FALSE)\n  \n  photo_bin <- binarize_fisheye(photo)\n  \n  photoData <- as.data.frame(photo_bin)\n  \n  ratio <- length(which(photoData == 1)) / length(which(photoData == 0))\n  \n  percentSky <- length(which(photoData == 1)) / nrow(photoData)\n  \n  # Append the results to the data frame\n  results <- rbind(results, data.frame(\n    plot = file_path,\n    ratio = ratio,\n    percentSky = percentSky,\n    stringsAsFactors = FALSE\n  ))\n  \n}\n\nresults <- results %>%\n  mutate(plot = sub(\".JPG\", \"\", sub(\".*//\", \"\", results$plot)),\n         treat = as.numeric(sub(\".*_\", \"\", plot)))\n\nresults <- left_join(results, index, by = join_by(plot, treat))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nkable(results)\n```\n\n::: {.cell-output-display}\n\n\n|plot |     ratio| percentSky| treat|site   | Photo.ID|\n|:----|---------:|----------:|-----:|:------|--------:|\n|10_0 | 0.1746233|  0.1486632|     0|DALTON |     1445|\n|11_0 | 0.2435451|  0.1958474|     0|DALTON |     1435|\n|12_1 | 1.1441331|  0.5336110|     1|DALTON |     1410|\n|15_3 | 0.7507232|  0.4288075|     3|DALTON |     1399|\n|16_2 | 1.4706656|  0.5952508|     2|DALTON |     1453|\n|17_3 | 0.7460729|  0.4272862|     3|STEESE |     1505|\n|18_1 | 0.5084734|  0.3370781|     1|STEESE |     1516|\n|19_2 | 0.4659223|  0.3178356|     2|STEESE |     1528|\n|2_3  | 0.5401879|  0.3507286|     3|STEESE |     1519|\n|22_3 | 0.6296953|  0.3863884|     3|STEESE |     1504|\n|23_3 | 0.5919714|  0.3718480|     3|STEESE |     1518|\n|24_3 | 1.0248911|  0.5061463|     3|STEESE |     1511|\n|25_3 | 0.6134905|  0.3802257|     3|STEESE |     1507|\n|26_2 | 1.2169560|  0.5489311|     2|STEESE |     1512|\n|27_2 | 1.8369597|  0.6475100|     2|STEESE |     1522|\n|28_1 | 2.7322672|  0.7320663|     1|STEESE |     1529|\n|29_1 | 0.6071337|  0.3777742|     1|STEESE |     1517|\n|3_2  | 0.4905932|  0.3291261|     2|STEESE |     1524|\n|33_1 | 0.8058943|  0.4462577|     1|STEESE |     1513|\n|34_2 | 0.7007807|  0.4120347|     2|STEESE |     1503|\n|35_3 | 1.4096601|  0.5850037|     3|STEESE |     1509|\n|36_1 | 0.8700637|  0.4652588|     1|STEESE |     1520|\n|37_3 | 0.4515839|  0.3110974|     3|DALTON |     1395|\n|4_2  | 0.4909976|  0.3293081|     2|STEESE |     1523|\n|40_2 | 0.7864964|  0.4402452|     2|DALTON |     1480|\n|41_1 | 2.6747496|  0.7278726|     1|DALTON |     1446|\n|42_1 | 2.1638783|  0.6839322|     1|DALTON |     1501|\n|44_0 | 0.1648066|  0.1414884|     0|DALTON |     1450|\n|47_2 | 0.7421887|  0.4260094|     2|DALTON |     1394|\n|48_1 | 2.6706692|  0.7275701|     1|DALTON |     1448|\n|50_1 | 0.7569991|  0.4308478|     1|DALTON |     1417|\n|52_1 | 0.3861226|  0.2785631|     1|DALTON |     1428|\n|54_3 | 0.6794471|  0.4045659|     3|DALTON |     1403|\n|55_3 | 1.2984896|  0.5649317|     3|DALTON |     1401|\n|58_0 | 0.2065476|  0.1711889|     0|DALTON |     1443|\n|64_1 | 1.1790658|  0.5410878|     1|DALTON |     1418|\n|65_1 | 1.0632665|  0.5153316|     1|DALTON |     1424|\n|7_3  | 0.9310793|  0.4821549|     3|DALTON |     1409|\n|8_2  | 0.4157489|  0.2936601|     2|DALTON |     1473|\n\n\n:::\n:::\n\n\n# How does canopy openness differ across reburn?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(results, aes(x = as.factor(treat), \n                    y = percentSky*100, fill = site)) +\n  geom_boxplot() +\n  labs(x = \"Number of Fires\", y = \"Percent Sky %\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n# What's the relationship between canopy openess and tree density?\n\n\n::: {.cell}\n\n:::\n\n\n# What's the relationship between canopy openess and solar irradiance?\n\nI've also used solar irradiance before as a proxy for light availability. How similar are those metrics?\n\n\n::: {.cell}\n\n:::\n\n\n# More Resources\n\n## Session Info\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.4.1 (2024-06-14)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Sonoma 14.0\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: America/Chicago\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] cowplot_1.1.3    lubridate_1.9.3  forcats_1.0.0    stringr_1.5.1   \n [5] dplyr_1.1.4      purrr_1.0.2      readr_2.1.5      tidyr_1.3.1     \n [9] tibble_3.2.1     ggplot2_3.5.1    tidyverse_2.0.0  kableExtra_1.4.0\n[13] hemispheR_1.1.4  terra_1.7-78    \n\nloaded via a namespace (and not attached):\n [1] gtable_0.3.5         xfun_0.45            raster_3.6-26       \n [4] htmlwidgets_1.6.4    lattice_0.22-6       tzdb_0.4.0          \n [7] vctrs_0.6.5          tools_4.4.1          generics_0.1.3      \n[10] proxy_0.4-27         fansi_1.0.6          pkgconfig_2.0.3     \n[13] KernSmooth_2.23-24   checkmate_2.3.2      lifecycle_1.0.4     \n[16] farver_2.1.2         compiler_4.4.1       munsell_0.5.1       \n[19] ijtiff_2.3.4         dismo_1.3-14         codetools_0.2-20    \n[22] htmltools_0.5.8.1    class_7.3-22         yaml_2.3.8          \n[25] pillar_1.9.0         classInt_0.4-10      tidyselect_1.2.1    \n[28] digest_0.6.36        stringi_1.8.4        sf_1.0-16           \n[31] labeling_0.4.3       fastmap_1.2.0        grid_4.4.1          \n[34] colorspace_2.1-0     cli_3.6.3            magrittr_2.0.3      \n[37] utf8_1.2.4           e1071_1.7-14         withr_3.0.0         \n[40] autothresholdr_1.4.2 backports_1.5.0      scales_1.3.0        \n[43] sp_2.1-4             timechange_0.3.0     rmarkdown_2.27      \n[46] hms_1.1.3            evaluate_0.24.0      knitr_1.47          \n[49] viridisLite_0.4.2    rlang_1.1.4          Rcpp_1.0.12         \n[52] zeallot_0.1.0        glue_1.7.0           DBI_1.2.3           \n[55] xml2_1.3.6           strex_2.0.0          svglite_2.1.3       \n[58] rstudioapi_0.16.0    jsonlite_1.8.8       R6_2.5.1            \n[61] systemfonts_1.1.0    units_0.8-5         \n```\n\n\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}