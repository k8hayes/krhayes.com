{
  "hash": "175a33400c23fcbb16b57c78ee032e11",
  "result": {
    "markdown": "---\ntitle: \"Benchmarking Reburning in iLand\"\nsubtitle: \"Using terra to quantify overlaps in fire perimeter rasters\"\ndate: \"2024-04-15\"\ncategories: [Spatial Data Analysis, Benchmarking]\ndate-modified: last-modified\nformat:\n  html:\n    toc: true\n    toc-location: left\n    grid:\n      margin-width: 350px\nreference-location: margin\ncitation-location: margin\ndraft: true\n---\n\n\n# Fire output in iLand\n\n## Determining which fires in iLand were stand-replacing\n\nFirst, I need to determine which fires in my iLand run were \"stand-replacing\" - The fire output in iLand produces a table of each fire, shown below.\n\n\n::: {.cell .tbl-cap-location-margin}\n\n:::\n\n\nThere's two ways to represent fire severity using this output: the **proportion of trees killed** within each fire, and the **proportion of basal area killed**. Those two metrics are distinct in slight yet important ways - a fire might kill all trees in a young stand but if the trees themselves were small, the impact on basal area won't be terribly large. Or, a fire might kill only the largest/oldest individuals in a stand, thus impacting carbon greatly in a way that wouldn't show up using just **proportion of trees killed**. Here, since we're interested in how forests are regenerating, we'll focus on instances where fires killed all trees, but I'll show both for the sake of it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# drop the fire years where there was no burn\n  fire <- fire[fire$area_m2 > 0,] # no fire years with no burn\n  length(unique(fire$fireId)) # how many fires occurred across the simulation?\n\n  fire <- fire %>% \n    mutate( # how many trees were killed?\n              prop.dens.killed = n_trees_died / n_trees, \n            # what basal area was killed?\n              prop.ba.killed = basalArea_died / basalArea_total) \n      \n      fire$prop.ba.killed[fire$basalArea_total == 0] <- 0 # set to 0\n      fire$prop.dens.killed[fire$n_trees == 0] <- 0\n```\n:::\n\n\nHowever, there's one challenge with this:\n\n\n::: {.cell .caption-margin}\n\n```{.r .cell-code}\nhist(fire$prop.dens.killed * 100,\n     breaks = seq(0, 100, 5),\n     main = paste0(\"Stems killed in fires. Mean: \", \n              round((mean(fire$prop.dens.killed)*100.0), 1), \"%\"),\n     xlab = \"Percent of stems killed\")\n```\n:::\n\n::: {.cell .caption-margin}\n\n```{.r .cell-code}\nhist(fire$prop.ba.killed * 100,\n     breaks = seq(0, 100, 5),\n     main = paste0(\"Basal area killed in fires. Mean: \",\n                   round((mean(fire$prop.ba.killed)*100.0), 1), \"%\"),\n     xlab = \"Percent of basal area killed\")\n```\n:::\n\n\nYou'll notice neither metric shows values that are completely equal to 100%. At first this seems like a problem, right?[^1]\n\n[^1]: none of our fires were stand-replacing??\n\nThis is an important nuance of the iLand fire output - **n_trees_killed** and **basalArea_died** are aggregated across the entire fire. Cells within the fire may have experienced full canopy mortality, but since we're working with averages, it'll be very very rare (if not impossible) for a stand to have 100% of stems killed across the entire fire.\n\n## Saving additional fire output\n\nWe'll need more detail, and thankfully there's a fun way to solve this - by adding a javascript file to the **scripts** folder, you can add code that tells iLand to save raster files of the perimeter of each fire with additional information. Some options of things to turn on include:\n\n-   **crownKill**: fraction of the crown killed within a burned resource unit (see [wildfire](https://iland-model.org/wildfire \"fire disturbance modeling\") ).\n-   **diedStemsFrac**: fraction of killed trees within a burned resource unit\n-   **diedBasalArea**: basal area (sum over resource units) of burnt trees.\n-   **KBDI**: Keetch Byram Drought Index (see [wildfire](https://iland-model.org/wildfire \"fire disturbance modeling\") ).\n-   **baseIgnition**: base probability of an annual fire ignition event for a cell on RU level (depending on fire-return-interval and average fire size)\n-   **fuel**: burned fuel (forest floor + dwd) kg/ha\n-   **combustibleFuel**: \"available combustible fuel (current KBDI, forest floor + dwd) kg/ha\n-   **nFire**: cumulative count of fire events on a resource unit[^2]\n-   **lastFireYear**: simulation year of the last fire event on a RU\n\n[^2]: Breaking the forth wall: discovered this output while putting together this quarto document. In future runs, I'll turn this on and avoid some of the steps described later in the document to filter out reburns\n\nFor this analysis, we'll stick to **diedStemsFrac** - the number of stems killed within a resource unit. First, you need to add a function into your iLand model to tell it to save the extra output.\n\nThe code to do so is the following:\n\n\n::: {.cell}\n\n```{.js .cell-code}\nfunction afterFireProcessing() {\n   var praefix = Globals.year;\n   var pid= Fire.id;\n   // save the form of the fire in ESRI raster format\n   // save a file for each fire\n   Fire.grid(\"diedStemsFrac\").save('output/dead/dead_'+ pid +'.txt')\n}\n```\n:::\n\n\nAdd this in to a javascript file within the **Scripts** folder in your iLand folder ecosystem, and enable \\<management\\> under \\</model\\> in your project file. Now, if you set up a **\"dead\"** folder in your output, a raster of values of stems killed will save after each fire.[^3]\n\n[^3]: To track other items from the list of variables above, call a new Fire.grid() within the afterFireProcessing function and give it a unique save destination\n\nIn order to filter our sapling output by the cells that experienced canopy-replacing fire, we can filter not only by the rasters (the footprint of the fire), but by the value of **diedStemsFraction** variable within each raster pixel (which represent resource units in the iLand landscape).\n\n::: callout-note\nQuestion: does **diedStemsFraction** include saplings and trees or just trees?\n:::\n\nThen, load the fire perimeters into R:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# stacking fire spread files\n      path = \"D:/workspace/Kate/iland/model/output/dead/snapshot\"\n      fire_maps = rast(list.files(path, full.names = T))\n    \n# also bring in the environment grid \n  # we'll use this to get ids for each grid\n      env.grid = rast(\"D:/workspace/Kate/iland/materials/env/env.grid.tif\")\n```\n:::\n\n\nThe function **rast()** from the *terra* package [@terra] creates a **SpatRaster** object, a object type in R that can represent multi-layer or multi-variable raster data. Here, the object **fire_maps** we just created is a three-dimensional raster - the first two dimensions are the x and y axis of our iLand landscape and the third dimension is 27 layers of fire perimeters (one for each fire within the simulation). Each pixel within that raster represents an individual resource unit from the iLand landscape and contains a value from 0 -1, representing **diedStemsFrac.**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfire_maps \n\nnlyr(fire_maps) # 27 layers, one for each fire\n\nhead(values(fire_maps))\n```\n:::\n\n\nWe can call on each of those 27 layers to examine the fire perimeters one by one. For example, this is the fire perimeter from the first fire in the simulation:\n\n\n::: {.cell .caption-margin}\n\n:::\n\n\nWe'll use these rasters to determine which resource units experienced stand-replacing fire[^4], and use those resource unit IDs to filter the sapling and tree data.\n\n[^4]: Which we can now define more specifically as **diedStemFrac** = 1\n\n::: callout-note\nAn aside: this run is a spin-up simulation - I ran iLand, initializing forests from an empty landscape[^5] in year 0, and simulated forest growth and fire over 300 years. This seems to be the sweet spot for simulation runs - at year 300, we have a landscape full of a mix of mature, regenerating and recently burned stands, just as we'd observe in real life. Since fires that occur early in the spin-up inherently burn young stands, it's not terribly representative of the relationship between height and age in regrowth that we want to eventually compare to the herbivore-impacted relationship. So, we'll filter to just the last 100 years of the simulation.\n:::\n\n[^5]: An aside to the aside (meta!!) - it's an empty landscape in the sense that there are no trees in year 0, but we do initialize using a soil organic layer that varies heterogeneously according to XX across the landscape. This isn't just to represent real life for real life's sake - initializing from truly empty (truly bare ground) causes totally different patterns of forests. As has been shown in decades of work in Alaska by Jill Johnstone and others, soil organic layer filters forest community composition in really critical ways, allowing spruce to outcompete species like birch and aspen which can't persist in thick soil or moss layers for as long.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n  # filtering to last 100 years of fire\n  fire100 <- fire %>%\n    filter(year >200)\n  length(unique(fire100$fireId)) # How many fires in the last 100 years?\n  unique(fire100$fireID)\n  \n  # dropping layers from fire raster\n  fire_maps100 <- subset(fire_maps, paste0(\"dead_\", fire100$fireId))\n```\n:::\n\n\n### A quick (haha) aside: Reburns\n\n::: column-margin\nyou can take the girl out of the Reburn PhD, but you can't take the Reburn PhD out of the girl\n:::\n\nEven within the relatively narrow window of 100 years[^6], reburning occurs within the model! Here's the footprint of all fires in the last 100 years of the spin up - you can see there's some considerable overlap, or reburning.\n\n[^6]: Particularly since the historic fire return interval for this system was somewhere between 100-300 years [@kelly2013]\n\n\n::: {.cell .caption-margin}\n\n```{.r .cell-code}\n  # setting background to NA to make transparent\n  fire_mapsNA <- subst(fire_maps100, 0, NA) # need to do this anyways but now it'll let us stack\n  \n  plot(fire_mapsNA[\"dead_18\"])\n  plot(fire_mapsNA[\"dead_19\"], add = TRUE, legend = FALSE)\n  plot(fire_mapsNA[\"dead_20\"], add = TRUE, legend = FALSE)\n  plot(fire_mapsNA[\"dead_21\"], add = TRUE, legend = FALSE)\n  plot(fire_mapsNA[\"dead_22\"], add = TRUE, legend = FALSE)\n  plot(fire_mapsNA[\"dead_23\"], add = TRUE, legend = FALSE)\n  plot(fire_mapsNA[\"dead_24\"], add = TRUE, legend = FALSE)\n  plot(fire_mapsNA[\"dead_25\"], add = TRUE, legend = FALSE)\n  plot(fire_mapsNA[\"dead_26\"], add = TRUE, legend = FALSE)\n  plot(fire_mapsNA[\"dead_27\"], add = TRUE, legend = FALSE)\n```\n:::\n\n\n#### Determining overlap between rasters using the *terra* package\n\nI'm curious both about the overlap between fire perimeters and the interaction of fire severity\n\n##### Fire perimeter reburning\n\nThe **intersect()** function in *terra* is useful for checking overlap, but only takes two rasters at a time:\n\n\n::: {.cell .caption-margin}\n\n```{.r .cell-code}\noverlap <- terra::intersect(fire_mapsNA[[\"dead_18\"]],\n                            fire_mapsNA[[\"dead_19\"]])\n\nplot(overlap)\n```\n:::\n\n\nIdeally, we'd be able to check the intersect of all of the fires at once - I'm sure there's a way to do this in a loop, but I'm not strong enough with loops to get it to work. I've tried the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\noverlap <- rast()\n\nfor (i in 1:length(fire100$fireId)) {\n  \n    fire1 <- fire_mapsNA[[paste0(\"dead_\", fire100$fireId[i])]]\n    fire2 <- fire_mapsNA[[paste0(\"dead_\", \n                                 ifelse(i != max(fire100$fireId), i+1,\n                                        max(fire100$fireId)))]]\n    \n    temp <- intersect(fire1,fire2)\n    names(temp) <- paste0(\"intersect_\", i)\n    overlap <- rast(temp)\n}\n```\n:::\n\n\nWhich doesn't work.\n\nThere's also the **mosaic()** function in *terra*:\n\n\n::: {.cell .caption-margin}\n\n```{.r .cell-code}\n# split all the layers into a list\nmapList <- terra::split(fire_mapsNA, 1:nlyr(fire_mapsNA))\n\n# turn list into SpatRaster Collection\nmapSPC <- terra::sprc(mapList) \n\n# merge values across layers\nreburn <- terra::mosaic(mapSPC, fun = \"sum\")\nplot(reburn)\n```\n:::\n\n\nYay!! Okay!! Now, if we set all the values of the layers to 1, we'll end up with a raster of number of fires.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nperim <- fire_maps100 > 0\n\n# setting values to 1 and na\nperim <- subst(perim, TRUE, 1, others = NA)\n```\n:::\n\n::: {.cell .caption-margin}\n\n```{.r .cell-code}\n# split all the layers into a list\nperimList <- terra::split(perim, 1:nlyr(perim))\n\n# turn list into SpatRaster Collection\nperimSPC <- terra::sprc(perimList) \n\n# merge values across layers\nnFire <- terra::mosaic(perimSPC, fun = \"sum\")\nplot(nFire)\n```\n:::\n\n\nyay!! Now we can filter by the value of **nFire** to get the specific resource units that burned and eventually exclude them for the analysis.\n\nA few more exploratory tangential questions since we're here:\n\nHow much of the landscape burned once?\n\n\n::: {.cell .caption-margin}\n\n```{.r .cell-code}\nnfire1 <- subst(nFire, 1, 1, others = NA)\nplot(nfire1)\n\n# what RID burned once?\nnfire1rid <- as.data.frame(mask(env.grid, nfire1))\n\n# how many unique resource units are there?\ndomain <- ncell(env.grid) # dimensions are 239 by 255 \n\n# how many resource units burned once?\nlength(unique(nfire1rid$env.grid)) \n\n# so, what %?\nround((length(unique(nfire1rid$env.grid)) / domain) *100, 1)\n```\n:::\n\n\nHow much burned twice?\n\n\n::: {.cell .caption-margin}\n\n```{.r .cell-code}\nnfire2 <- subst(nFire, 2, 1, others = NA)\nplot(nfire2)\n\n# what RID burned twice?\nnfire2rid <- as.data.frame(mask(env.grid, nfire2))\n\n# so, what %?\nround((length(unique(nfire2rid$env.grid)) / domain) *100, 1)\n```\n:::\n\n\nHow much burned three times?\n\n\n::: {.cell .caption-margin}\n\n```{.r .cell-code}\nnfire3 <- subst(nFire, 3, 1, others = NA)\nplot(nfire3)\n\n# what RID burned thrice?\nnfire3rid <- as.data.frame(mask(env.grid, nfire3))\n\n# so, what %?\nround((length(unique(nfire3rid$env.grid)) / domain) *100, 1)\n```\n:::\n\n\nNow, we can introduce one more layer: these are all cells that burned, not the cells that burned at high severity. In theory, we[^7] often expect reburns (or fires that burn into existing fire perimeters) to occur at diminishing severity. Depending on the window between fires, fuel availability may limit combustion in reburns. Based on that logic, are there overlaps between stands that burned at high severity?\n\n[^7]: we, the royal fire ecologists\n\n\n::: {.cell .caption-margin}\n\n```{.r .cell-code}\n# filter to just stands with high severity\n  # cells with diedStemsFrac = 1\n  fire_mapsHS <- subst(fire_maps, 1, 1, others = NA)\n  \n  plot(fire_mapsHS[[\"dead_18\"]])\n  plot(fire_mapsHS[[\"dead_19\"]], add = TRUE, legend = FALSE)\n  plot(fire_mapsHS[[\"dead_20\"]], add = TRUE, legend = FALSE)\n  plot(fire_mapsHS[[\"dead_21\"]], add = TRUE, legend = FALSE)\n  plot(fire_mapsHS[[\"dead_22\"]], add = TRUE, legend = FALSE)\n  plot(fire_mapsHS[[\"dead_23\"]], add = TRUE, legend = FALSE)\n  plot(fire_mapsHS[[\"dead_24\"]], add = TRUE, legend = FALSE)\n  plot(fire_mapsHS[[\"dead_25\"]], add = TRUE, legend = FALSE)\n  plot(fire_mapsHS[[\"dead_26\"]], add = TRUE, legend = FALSE)\n  plot(fire_mapsHS[[\"dead_27\"]], add = TRUE, legend = FALSE)\n```\n:::\n\n\nObviously less area there. Is there any overlap?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# split all the layers into a list\nhsList <- terra::split(fire_mapsHS, 1:nlyr(fire_mapsHS))\n\n# turn list into SpatRaster Collection\nhsSPC <- terra::sprc(hsList) \n\n# merge values across layers\nnFireHS <- terra::mosaic(hsSPC, fun = \"sum\")\nplot(nFireHS)\n```\n:::\n\n\nOkay. Pretty sparse, but technically there's still resource units that burned completely both times.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnfireHS2 <- subst(nFireHS, 2, 1, others = NA)\nplot(nfireHS2)\n\n# what RID burned twice at HS?\nnfireHS2rid <- as.data.frame(mask(env.grid, nfireHS2))\n\n# so, what %?\n(length(unique(nfireHS2rid$env.grid)) / domain) *100\n```\n:::\n\n\nI'm curious about the years that burned twice at high severity. What's the interval between them?\n\n\n::: {.cell}\n\n:::\n\n\n## Filtering sapling by high severity fire\n\nNow, we want to use the row id numbers from the **fire_mapsHS** object to filter out rows in the **sapling** and **stand** output that burned at high severity. The following code loops through each of the fire maps, extracting the resource unit ID numbers, the fire ID and the fire year (which come from the default fire output) and compiling into a dataframe, **fireID**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfireID <- data.frame()\n\nfor (i in 1:nrow(fire100)) {\n  \n  # Skip fires that burned nothing\n  if (fire100$area_m2[i] > 0) {\n  \n    mask <- fire_mapsHS[[paste0(\"dead_\", fire100$fireId[i])]]\n    \n    # Use the mask to extract the rids for burned grids\n    burned_rids <- as.data.frame(mask(env.grid, mask))\n    burned_rids= burned_rids%>%filter(!is.na(env.grid))\n    burned_rids$year=fire100$year[i]\n    burned_rids$fireID = fire100$fireId[i]\n  }\n  \n  fireID = rbind(fireID, burned_rids)\n}\n\nfireID = fireID %>% rename(\"rid\" = env.grid, \"fire.year\" = year)\n```\n:::\n\n\nWhat fraction of the landscape burned at high severity? (ie, how many resource units?)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# how many unique resource units are there?\ndomain <- ncell(env.grid) # dimensions are 239 by 255 \n\n# how many resource units burned at HS?\nlength(unique(fireID$rid)) \n\n# so, what %?\n(length(unique(fireID$rid)) / domain) *100\n```\n:::\n\n\nSo, only about 1% of the landscape burned at high severity across the 100 year simulation window. (Though, technically that would be an underestimate since it doesn't take into account the resource units that reburned). Let's go ahead and exclude the resource units that reburned:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n  fireID <- fireID %>%\n      filter(rid %in% nfireHS2rid$env.grid)\n```\n:::\n\n\n## Session info\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.3.3 (2024-02-29)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Sonoma 14.0\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: America/Chicago\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.4 compiler_4.3.3    fastmap_1.1.1     cli_3.6.2        \n [5] tools_4.3.3       htmltools_0.5.8   rstudioapi_0.16.0 yaml_2.3.8       \n [9] rmarkdown_2.26    knitr_1.45        jsonlite_1.8.8    xfun_0.43        \n[13] digest_0.6.35     rlang_1.1.3       evaluate_0.23    \n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}